import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy import signal
from scipy.fft import fft
import pywt

def load_and_process_data(file_path):
    """
    加载并处理原始振动数据
    
    参数:
    - file_path: CSV文件路径
    
    返回:
    - 处理后的数据
    """
    # 加载数据
    data = pd.read_csv(file_path)
    
    # 重命名列（根据您的数据描述）
    data.columns = ['Time Stamp', 'X-axis', 'Y-axis', 'Z-axis']
    
    # 检查缺失值
    print(f"Missing values: {data.isnull().sum().sum()}")
    
    # 如果有缺失值，填充或删除
    data = data.dropna()
    
    # 转换时间戳（如果需要）
    # data['Time Stamp'] = pd.to_datetime(data['Time Stamp'])
    
    return data

def segment_data(data, window_size=1000, overlap=0.5):
    """
    将数据分割成固定大小的窗口
    
    参数:
    - data: 原始数据DataFrame
    - window_size: 窗口大小
    - overlap: 重叠比例(0-1之间)
    
    返回:
    - 分割后的数据段列表
    """
    segments = []
    step = int(window_size * (1 - overlap))
    
    # 提取特征列
    features = data[['X-axis', 'Y-axis', 'Z-axis']].values
    
    # 分割数据
    for i in range(0, len(features) - window_size + 1, step):
        segment = features[i:i + window_size]
        segments.append(segment)
    
    return np.array(segments)

def extract_time_domain_features(segments):
    """
    提取时域特征
    
    参数:
    - segments: 分割后的数据段
    
    返回:
    - 时域特征
    """
    features = []
    
    for segment in segments:
        segment_features = []
        
        for axis in range(segment.shape[1]):  # 遍历X、Y、Z轴
            axis_data = segment[:, axis]
            
            # 计算统计特征
            mean = np.mean(axis_data)
            std = np.std(axis_data)
            rms = np.sqrt(np.mean(np.square(axis_data)))
            peak = np.max(np.abs(axis_data))
            peak_to_peak = np.max(axis_data) - np.min(axis_data)
            crest = peak / rms if rms != 0 else 0
            kurtosis = np.sum((axis_data - mean)**4) / (len(axis_data) * std**4) if std != 0 else 0
            skewness = np.sum((axis_data - mean)**3) / (len(axis_data) * std**3) if std != 0 else 0
            
            # 添加到特征列表
            segment_features.extend([mean, std, rms, peak, peak_to_peak, crest, kurtosis, skewness])
        
        features.append(segment_features)
    
    return np.array(features)

def extract_frequency_domain_features(segments, fs=10000):
    """
    提取频域特征
    
    参数:
    - segments: 分割后的数据段
    - fs: 采样频率
    
    返回:
    - 频域特征
    """
    features = []
    
    for segment in segments:
        segment_features = []
        
        for axis in range(segment.shape[1]):  # 遍历X、Y、Z轴
            axis_data = segment[:, axis]
            
            # 计算FFT
            spectrum = np.abs(fft(axis_data))
            freq = np.fft.fftfreq(len(axis_data), d=1/fs)
            
            # 只保留正频率部分
            positive_freq_idx = np.where(freq > 0)[0]
            spectrum = spectrum[positive_freq_idx]
            freq = freq[positive_freq_idx]
            
            # 计算频域特征
            dominant_freq = freq[np.argmax(spectrum)]
            mean_freq = np.sum(freq * spectrum) / np.sum(spectrum) if np.sum(spectrum) != 0 else 0
            median_freq = freq[np.argmax(np.cumsum(spectrum) >= np.sum(spectrum)/2)]
            
            # 频带能量
            freq_bands = [0, 500, 1000, 2000, 5000]
            band_energy = []
            
            for i in range(len(freq_bands)-1):
                lower = freq_bands[i]
                upper = freq_bands[i+1]
                band_idx = np.where((freq >= lower) & (freq < upper))[0]
                band_energy.append(np.sum(spectrum[band_idx]))
            
            # 添加到特征列表
            segment_features.extend([dominant_freq, mean_freq, median_freq] + band_energy)
        
        features.append(segment_features)
    
    return np.array(features)

def extract_wavelet_features(segments, wavelet='db4', level=4):
    """
    提取小波特征
    
    参数:
    - segments: 分割后的数据段
    - wavelet: 小波类型
    - level: 分解级别
    
    返回:
    - 小波特征
    """
    features = []
    
    for segment in segments:
        segment_features = []
        
        for axis in range(segment.shape[1]):  # 遍历X、Y、Z轴
            axis_data = segment[:, axis]
            
            # 小波分解
            coeffs = pywt.wavedec(axis_data, wavelet, level=level)
            
            # 计算每个子带的能量
            energies = [np.sum(np.square(coeff)) for coeff in coeffs]
            
            # 计算每个子带的标准差
            stds = [np.std(coeff) for coeff in coeffs]
            
            # 添加到特征列表
            segment_features.extend(energies + stds)
        
        features.append(segment_features)
    
    return np.array(features)

def normalize_features(features):
    """
    归一化特征
    
    参数:
    - features: 特征矩阵
    
    返回:
    - 归一化后的特征
    """
    mean = np.mean(features, axis=0)
    std = np.std(features, axis=0)
    
    # 避免除以零
    std[std == 0] = 1
    
    normalized_features = (features - mean) / std
    
    return normalized_features, mean, std

def prepare_data_for_deep_learning(file_path, window_size=1000, overlap=0.5, label=None):
    """
    为深度学习准备数据
    
    参数:
    - file_path: CSV文件路径
    - window_size: 窗口大小
    - overlap: 重叠比例
    - label: 当前数据的标签(类别)
    
    返回:
    - 准备好的数据和标签
    """
    # 加载并处理数据
    data = load_and_process_data(file_path)
    
    # 分割数据
    segments = segment_data(data, window_size, overlap)
    
    # 如果提供了标签，创建标签数组
    if label is not None:
        labels = np.full(len(segments), label)
        return segments, labels
    
    return segments

def data_augmentation(segments, noise_level=0.05, time_shift_max=50):
    """
    数据增强
    
    参数:
    - segments: 原始数据段
    - noise_level: 添加噪声的级别
    - time_shift_max: 最大时间偏移
    
    返回:
    - 增强后的数据
    """
    augmented_segments = []
    
    for segment in segments:
        # 原始数据
        augmented_segments.append(segment)
        
        # 添加噪声
        noise = np.random.normal(0, noise_level * np.std(segment), segment.shape)
        augmented_segments.append(segment + noise)
        
        # 时间偏移
        shift = np.random.randint(-time_shift_max, time_shift_max)
        shifted = np.roll(segment, shift, axis=0)
        augmented_segments.append(shifted)
        
        # 振幅缩放
        scale = np.random.uniform(0.9, 1.1)
        augmented_segments.append(segment * scale)
    
    return np.array(augmented_segments)

def visualize_data(data, title="振动数据可视化"):
    """
    可视化振动数据
    
    参数:
    - data: 振动数据DataFrame
    - title: 图表标题
    """
    plt.figure(figsize=(15, 10))
    
    # 绘制X轴振动
    plt.subplot(3, 1, 1)
    plt.plot(data['Time Stamp'].values[:1000], data['X-axis'].values[:1000])
    plt.title(f"{title} - X轴")
    plt.xlabel("时间")
    plt.ylabel("振幅")
    
    # 绘制Y轴振动
    plt.subplot(3, 1, 2)
    plt.plot(data['Time Stamp'].values[:1000], data['Y-axis'].values[:1000])
    plt.title(f"{title} - Y轴")
    plt.xlabel("时间")
    plt.ylabel("振幅")
    
    # 绘制Z轴振动
    plt.subplot(3, 1, 3)
    plt.plot(data['Time Stamp'].values[:1000], data['Z-axis'].values[:1000])
    plt.title(f"{title} - Z轴")
    plt.xlabel("时间")
    plt.ylabel("振幅")
    
    plt.tight_layout()
    plt.show()

def visualize_frequency_spectrum(data, fs=10000, title="频谱分析"):
    """
    可视化频谱
    
    参数:
    - data: 振动数据DataFrame
    - fs: 采样频率
    - title: 图表标题
    """
    plt.figure(figsize=(15, 10))
    
    # 计算X轴频谱
    x_spectrum = np.abs(fft(data['X-axis'].values[:1000]))
    freqs = np.fft.fftfreq(1000, d=1/fs)
    
    # 只保留正频率部分
    positive_freq_idx = np.where(freqs > 0)[0]
    x_spectrum = x_spectrum[positive_freq_idx]
    freqs = freqs[positive_freq_idx]
    
    # 绘制X轴频谱
    plt.subplot(3, 1, 1)
    plt.plot(freqs, x_spectrum)
    plt.title(f"{title} - X轴")
    plt.xlabel("频率 (Hz)")
    plt.ylabel("幅度")
    
    # 计算Y轴频谱
    y_spectrum = np.abs(fft(data['Y-axis'].values[:1000]))
    y_spectrum = y_spectrum[positive_freq_idx]
    
    # 绘制Y轴频谱
    plt.subplot(3, 1, 2)
    plt.plot(freqs, y_spectrum)
    plt.title(f"{title} - Y轴")
    plt.xlabel("频率 (Hz)")
    plt.ylabel("幅度")
    
    # 计算Z轴频谱
    z_spectrum = np.abs(fft(data['Z-axis'].values[:1000]))
    z_spectrum = z_spectrum[positive_freq_idx]
    
    # 绘制Z轴频谱
    plt.subplot(3, 1, 3)
    plt.plot(freqs, z_spectrum)
    plt.title(f"{title} - Z轴")
    plt.xlabel("频率 (Hz)")
    plt.ylabel("幅度")
    
    plt.tight_layout()
    plt.show()

# 示例：如何使用上面的函数
if __name__ == "__main__":
    # 1. 加载数据
    # file_path = "0.7inner100watt67V2Iv.csv"
    # data = load_and_process_data(file_path)
    
    # 2. 数据可视化
    # visualize_data(data)
    # visualize_frequency_spectrum(data)
    
    # 3. 数据分割
    # segments = segment_data(data)
    
    # 4. 特征提取
    # time_features = extract_time_domain_features(segments)
    # freq_features = extract_frequency_domain_features(segments)
    # wavelet_features = extract_wavelet_features(segments)
    
    # 5. 特征归一化
    # normalized_features, mean, std = normalize_features(time_features)
    
    # 6. 数据增强
    # augmented_segments = data_augmentation(segments)
    
    print("示例代码完成")